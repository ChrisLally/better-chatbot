[
  {
    "schemaname": "public",
    "functionname": "handle_chat_message_inserted",
    "functionowner": "postgres",
    "returntype": "trigger",
    "arguments": "",
    "definition": "CREATE OR REPLACE FUNCTION public.handle_chat_message_inserted()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  task_id uuid;\n  project_id uuid;\n  step_name text;\n  step_description text;\n  sender_user_type public.platform_user_type_enum;\n  workspace_lead_agent_id uuid;\n  sender_name text;\nBEGIN\n  -- PREVENT LOOP: Skip messages that are already linked to a project task step\n  -- These are messages created as part of task execution, not new user requests\n  IF NEW.project_task_step_id IS NOT NULL THEN\n    RETURN NEW;\n  END IF;\n  \n  -- Get the sender's user type and name\n  SELECT user_type, name INTO sender_user_type, sender_name\n  FROM users\n  WHERE id = NEW.user_id;\n  \n  -- Get workspace lead agent for this chat\n  SELECT w.lead_agent_user_id INTO workspace_lead_agent_id\n  FROM chats c\n  JOIN workspaces w ON c.workspace_id = w.id\n  WHERE c.id = NEW.chat_id;\n  \n  -- Only proceed if we found a workspace lead agent\n  IF workspace_lead_agent_id IS NULL THEN\n    RETURN NEW;\n  END IF;\n  \n  -- Process messages from anyone EXCEPT the workspace lead agent\n  -- This allows both humans AND other agents to trigger the lead agent\n  IF NEW.user_id != workspace_lead_agent_id THEN\n    \n    -- Get the primary project ID from the chat\n    SELECT primary_project_id INTO project_id\n    FROM chats \n    WHERE id = NEW.chat_id;\n    \n    -- Generate dynamic step name based on sender type\n    IF sender_user_type = 'human' THEN\n      step_name := 'Human User Requested Response';\n      step_description := 'Respond to human user in chat';\n    ELSE\n      step_name := sender_name || ' Requested Response';\n      step_description := 'Review agent work and respond in chat';\n    END IF;\n    \n    -- CREATE TASK AS DRAFT FIRST (won't trigger webhook yet)\n    INSERT INTO project_tasks (\n      project_id,\n      title,\n      description,\n      status,\n      assigned_user_id,\n      assigned_by_user_id\n    ) VALUES (\n      project_id,\n      'Chat Response: ' || COALESCE(LEFT(NEW.content, 50), 'Message'),\n      step_description,\n      'draft',\n      workspace_lead_agent_id,\n      NEW.user_id\n    ) RETURNING id INTO task_id;\n    \n    -- CREATE STEP WITH CHAT CONTEXT\n    INSERT INTO project_task_steps (\n      project_task_id,\n      assigned_user_id,\n      assigned_by_user_id,\n      name,\n      description,\n      next_step_context,\n      status,\n      chat_id,\n      chat_message_id\n    ) VALUES (\n      task_id,\n      workspace_lead_agent_id,\n      NEW.user_id,\n      step_name,\n      step_description,\n      NULL,\n      'working',\n      NEW.chat_id,\n      NEW.id\n    );\n    \n    -- NOW UPDATE TASK TO 'READY' - THIS WILL TRIGGER THE WEBHOOK\n    UPDATE project_tasks \n    SET status = 'ready' \n    WHERE id = task_id;\n    \n  END IF;\n  \n  RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "schemaname": "public",
    "functionname": "handle_new_user",
    "functionowner": "postgres",
    "returntype": "trigger",
    "arguments": "",
    "definition": "CREATE OR REPLACE FUNCTION public.handle_new_user()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  INSERT INTO public.users (\n    id,\n    name,\n    avatar_url,\n    timezone,\n    user_type,\n    agent_email,\n    created_at,\n    updated_at\n  )\n  VALUES (\n    NEW.id,\n    COALESCE(\n      NEW.raw_user_meta_data->>'name',\n      NEW.raw_user_meta_data->>'full_name',\n      split_part(NEW.email, '@', 1),\n      'User' -- Fallback name\n    ),\n    COALESCE(\n      NEW.raw_user_meta_data->>'avatar_url',\n      NEW.raw_user_meta_data->>'picture'\n    ),\n    COALESCE(\n      NEW.raw_user_meta_data->>'timezone',\n      'UTC'\n    ),\n    CASE \n      WHEN NEW.raw_user_meta_data->>'user_type' = 'agent' THEN 'agent'::public.platform_user_type_enum\n      ELSE 'human'::public.platform_user_type_enum\n    END,\n    CASE \n      WHEN NEW.raw_user_meta_data->>'user_type' = 'agent' THEN NEW.email\n      ELSE NULL\n    END,\n    NOW(),\n    NOW()\n  )\n  ON CONFLICT (id) \n  DO UPDATE SET\n    name = COALESCE(\n      NEW.raw_user_meta_data->>'name',\n      NEW.raw_user_meta_data->>'full_name',\n      split_part(NEW.email, '@', 1),\n      public.users.name, -- Keep existing name if no new data\n      'User' -- Final fallback\n    ),\n    avatar_url = COALESCE(\n      NEW.raw_user_meta_data->>'avatar_url',\n      NEW.raw_user_meta_data->>'picture',\n      public.users.avatar_url\n    ),\n    timezone = COALESCE(\n      NEW.raw_user_meta_data->>'timezone',\n      public.users.timezone,\n      'UTC'\n    ),\n    user_type = CASE \n      WHEN NEW.raw_user_meta_data->>'user_type' = 'agent' THEN 'agent'::public.platform_user_type_enum\n      ELSE COALESCE(public.users.user_type, 'human'::public.platform_user_type_enum)\n    END,\n    agent_email = CASE \n      WHEN NEW.raw_user_meta_data->>'user_type' = 'agent' THEN NEW.email\n      ELSE public.users.agent_email\n    END,\n    updated_at = NOW();\n  \n  RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "schemaname": "public",
    "functionname": "handle_project_task_orchestration",
    "functionowner": "postgres",
    "returntype": "trigger",
    "arguments": "",
    "definition": "CREATE OR REPLACE FUNCTION public.handle_project_task_orchestration()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$DECLARE\n  webhook_payload jsonb;\n  incomplete_deps_count integer;\n  blocked_task_id uuid;\n  task_ready boolean;\n  task_workspace_id uuid;\nBEGIN\n  -- Handle task completion (UPDATE: status changes to 'completed')\n  IF TG_OP = 'UPDATE' AND OLD.status != 'completed' AND NEW.status = 'completed' THEN\n    \n    -- Find all tasks that were blocked by this completed task\n    FOR blocked_task_id IN \n      SELECT DISTINCT blocked_project_task_id \n      FROM project_task_dependencies \n      WHERE blocking_project_task_id = NEW.id\n    LOOP\n      -- Check if this blocked task is now ready (all blocking tasks completed)\n      SELECT NOT EXISTS (\n        SELECT 1 \n        FROM project_task_dependencies dep\n        JOIN project_tasks blocking_task ON blocking_task.id = dep.blocking_project_task_id\n        WHERE dep.blocked_project_task_id = blocked_task_id\n          AND blocking_task.status != 'completed'\n      ) INTO task_ready;\n      \n      -- If task is ready and has an assigned user, change status to ready\n      IF task_ready THEN\n        UPDATE project_tasks \n        SET status = 'ready', \n            updated_at = NOW()\n        WHERE id = blocked_task_id \n          AND assigned_user_id IS NOT NULL\n          AND status = 'draft';  -- Only move draft tasks to ready\n          \n        -- ALSO UPDATE THE STEP STATUS from draft to working\n        UPDATE project_task_steps\n        SET status = 'working',\n            updated_at = NOW()\n        WHERE project_task_id = blocked_task_id\n          AND status = 'draft';\n      END IF;\n      \n    END LOOP;\n    \n  END IF;\n  \n  -- Handle webhook trigger (INSERT or UPDATE: task becomes 'ready' with assigned user)\n  IF NEW.assigned_user_id IS NOT NULL AND NEW.status = 'ready' THEN\n    -- Only trigger webhook if this is a new 'ready' status (INSERT or status changed to ready)\n    IF TG_OP = 'INSERT' OR (TG_OP = 'UPDATE' AND OLD.status != 'ready') THEN\n      \n      -- Check if task has incomplete dependencies\n      SELECT COUNT(*)\n      INTO incomplete_deps_count\n      FROM project_task_dependencies dep\n      JOIN project_tasks blocking_task ON blocking_task.id = dep.blocking_project_task_id\n      WHERE dep.blocked_project_task_id = NEW.id\n        AND blocking_task.status != 'completed';\n      \n      -- Only call webhook if no incomplete dependencies\n      IF incomplete_deps_count = 0 THEN\n        \n        -- Get workspace_id from project\n        SELECT p.workspace_id INTO task_workspace_id\n        FROM projects p\n        WHERE p.id = NEW.project_id;\n        \n        -- Build payload with essential task fields INCLUDING workspace_id\n        webhook_payload := jsonb_build_object(\n          'type', TG_OP,\n          'table', 'project_tasks',\n          'record', jsonb_build_object(\n            'id', NEW.id,\n            'project_id', NEW.project_id,\n            'workspace_id', task_workspace_id,  -- ADD workspace context\n            'assigned_user_id', NEW.assigned_user_id,\n            'assigned_by_user_id', NEW.assigned_by_user_id,\n            'title', NEW.title,\n            'description', NEW.description,\n            'status', NEW.status,\n            'created_at', NEW.created_at,\n            'updated_at', NEW.updated_at\n          )\n        );\n        \n        -- Send to task-trigger endpoint\n        PERFORM net.http_post(\n          url := 'https://unison.fide.id/api/webhooks/task-trigger',\n          body := webhook_payload,\n          headers := '{\"Content-Type\": \"application/json\"}'::jsonb,\n          timeout_milliseconds := 5000\n        );\n        \n      END IF;\n      \n    END IF;\n  END IF;\n  \n  RETURN NEW;\nEND;$function$\n"
  },
  {
    "schemaname": "public",
    "functionname": "handle_workspace_created_chat_setup",
    "functionowner": "postgres",
    "returntype": "trigger",
    "arguments": "",
    "definition": "CREATE OR REPLACE FUNCTION public.handle_workspace_created_chat_setup()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    workspace_chat_id uuid;\nBEGIN\n    -- Validate that lead_agent_user_id is provided and exists\n    IF NEW.lead_agent_user_id IS NULL THEN\n        RAISE EXCEPTION 'Workspace creation requires lead_agent_user_id to be set (use /api/agents route first)';\n    END IF;\n    \n    -- Validate agent exists and is correct type\n    IF NOT EXISTS (\n        SELECT 1 FROM users \n        WHERE id = NEW.lead_agent_user_id \n        AND user_type = 'agent'\n    ) THEN\n        RAISE EXCEPTION 'Lead agent ID % is not a valid agent user', NEW.lead_agent_user_id;\n    END IF;\n    \n    -- Create the workspace chat (no name - client will show lead agent name)\n    INSERT INTO chats (\n        name,  -- NULL - client-side naming\n        description,\n        workspace_id,\n        primary_project_id,\n        active_task_id\n    )\n    VALUES (\n        NULL,  -- No fixed name, client determines display name\n        'Workspace coordination chat',\n        NEW.id,\n        NEW.default_project_id,\n        NULL\n    )\n    RETURNING id INTO workspace_chat_id;\n    \n    -- Add the lead agent as workspace member with conflict handling\n    INSERT INTO workspace_members (workspace_id, user_id, role)\n    VALUES (NEW.id, NEW.lead_agent_user_id, 'admin')\n    ON CONFLICT (workspace_id, user_id) DO NOTHING;\n    \n    -- Add the lead agent to the workspace chat as admin\n    INSERT INTO chat_members (chat_id, user_id, role)\n    VALUES (workspace_chat_id, NEW.lead_agent_user_id, 'admin')\n    ON CONFLICT (chat_id, user_id) DO NOTHING;\n    \n    RETURN NEW;\n    \nEXCEPTION\n    WHEN others THEN\n        RAISE EXCEPTION 'Failed to handle workspace creation for %: %', NEW.id, SQLERRM;\nEND;\n$function$\n"
  },
  {
    "schemaname": "public",
    "functionname": "handle_workspace_member_added",
    "functionowner": "postgres",
    "returntype": "trigger",
    "arguments": "",
    "definition": "CREATE OR REPLACE FUNCTION public.handle_workspace_member_added()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    workspace_chat_id uuid;\n    private_chat_id uuid;\n    lead_agent_id uuid;\n    member_user_type public.platform_user_type_enum;\n    member_name text;\n    workspace_name text;\nBEGIN\n    -- Validate user exists and get their info\n    SELECT user_type, name INTO member_user_type, member_name\n    FROM users \n    WHERE id = NEW.user_id;\n    \n    IF member_user_type IS NULL THEN\n        RAISE EXCEPTION 'User ID % not found', NEW.user_id;\n    END IF;\n    \n    -- Get workspace info\n    SELECT lead_agent_user_id, name INTO lead_agent_id, workspace_name\n    FROM workspaces\n    WHERE id = NEW.workspace_id;\n    \n    IF lead_agent_id IS NULL THEN\n        RAISE EXCEPTION 'Workspace % has no lead agent', NEW.workspace_id;\n    END IF;\n    \n    -- Find the workspace chat (unnamed chat with lead agent)\n    SELECT id INTO workspace_chat_id\n    FROM chats \n    WHERE workspace_id = NEW.workspace_id \n    AND name IS NULL  -- Find the unnamed workspace chat\n    AND EXISTS (\n        SELECT 1 FROM chat_members \n        WHERE chat_id = chats.id \n        AND user_id = lead_agent_id\n    )\n    LIMIT 1;\n    \n    -- Add the user to the workspace chat if it exists\n    IF workspace_chat_id IS NOT NULL THEN\n        INSERT INTO chat_members (\n            chat_id,\n            user_id,\n            role\n        ) VALUES (\n            workspace_chat_id,\n            NEW.user_id,\n            'member'\n        ) ON CONFLICT (chat_id, user_id) DO NOTHING;\n    ELSE\n        -- Log warning if workspace chat not found, but don't fail\n        RAISE WARNING 'Workspace chat not found for workspace %, user % not added to chat', \n                     NEW.workspace_id, NEW.user_id;\n    END IF;\n    \n    -- Create private 1:1 chat if this is a human user\n    IF member_user_type = 'human' THEN\n        -- Create private chat between human and lead agent (no name)\n        INSERT INTO chats (\n            name,  -- NULL - client shows other person's name\n            description, \n            workspace_id,\n            primary_project_id\n        )\n        SELECT \n            NULL,  -- No name - client-side naming\n            'Private chat',\n            NEW.workspace_id,\n            w.default_project_id\n        FROM workspaces w\n        WHERE w.id = NEW.workspace_id\n        RETURNING id INTO private_chat_id;\n        \n        -- Add both human and lead agent to the private chat\n        INSERT INTO chat_members (chat_id, user_id, role) VALUES\n            (private_chat_id, NEW.user_id, 'member'),\n            (private_chat_id, lead_agent_id, 'admin')\n        ON CONFLICT (chat_id, user_id) DO NOTHING;\n        \n    END IF;\n    \n    RETURN NEW;\n    \nEXCEPTION\n    WHEN others THEN\n        RAISE EXCEPTION 'Failed to handle workspace member addition for user % in workspace %: %', \n                       NEW.user_id, NEW.workspace_id, SQLERRM;\nEND;\n$function$\n"
  }
]
