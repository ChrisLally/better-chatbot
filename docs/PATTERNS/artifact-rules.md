# Artifact System Rules & Best Practices

*Architecture guidelines for artifact creation, storage, and management in the Unison agent system*

## Core Philosophy

**Principle**: Artifacts are immutable outputs generated by agents during task execution. They represent completed work products (reports, code, analyses) that can be reviewed, approved, and referenced. The artifact system provides traceability, versioning, and a central index for all agent-generated content.

---

## 1. Database Schema

### Core Table: `artifacts`

```sql
CREATE TABLE public.artifacts (
  id uuid DEFAULT gen_random_uuid() NOT NULL PRIMARY KEY,
  workspace_id uuid NOT NULL REFERENCES public.workspaces(id) ON DELETE CASCADE,
  project_id uuid NULL REFERENCES public.projects(id) ON DELETE SET NULL,
  source_project_task_step_id uuid NOT NULL REFERENCES public.project_task_steps(id) ON DELETE CASCADE,
  created_by_user_id uuid NOT NULL REFERENCES public.users(id) ON DELETE SET NULL,
  approved_by_user_id uuid NULL REFERENCES public.users(id) ON DELETE SET NULL,
  title text NOT NULL,
  description text NULL,
  content text NULL,
  storage_type artifact_storage_type_enum NOT NULL DEFAULT 'database',
  content_format artifact_format_enum NOT NULL DEFAULT 'markdown',
  status artifact_status_enum NOT NULL DEFAULT 'draft',
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

-- ENUM types
CREATE TYPE artifact_status_enum AS ENUM ('draft', 'under_review', 'approved', 'archived');
CREATE TYPE artifact_format_enum AS ENUM ('markdown', 'json', 'code', 'text');
CREATE TYPE artifact_storage_type_enum AS ENUM ('database', 'git_repository', 'object_storage', 'web_document');
```

### Mention System: `chat_message_mentions`

```sql
CREATE TABLE public.chat_message_mentions (
  id uuid DEFAULT gen_random_uuid() NOT NULL PRIMARY KEY,
  message_id uuid REFERENCES public.chat_messages(id) ON DELETE CASCADE,
  mentioned_user_id uuid REFERENCES public.users(id) ON DELETE CASCADE,
  mentioned_artifact_id uuid REFERENCES public.artifacts(id) ON DELETE CASCADE,
  created_at timestamptz DEFAULT now()
);
```

**Purpose**: Links chat messages to artifacts they reference, enabling:
- Clickable artifact links in UI
- Traceability (which messages reference which artifacts)
- Future: Notification system for artifact mentions

---

## 2. Key Schema Principles

### ✅ **Workspace-Scoped (CRITICAL)**
- **Rule**: Every artifact MUST belong to a workspace (`workspace_id` NOT NULL)
- **Why**: Ensures proper access control and organizational boundaries
- **Enforcement**: Foreign key constraint with CASCADE delete

### ✅ **Project-Optional (FLEXIBILITY)**
- **Rule**: Artifacts CAN be linked to a project (`project_id` NULL)
- **Why**: Supports both project-specific and workspace-level artifacts
- **Example**: Workspace-wide templates, brand guidelines vs project-specific reports

### ✅ **Step-Linked (TRACEABILITY)**
- **Rule**: Every artifact MUST link to the step that created it (`source_project_task_step_id` NOT NULL)
- **Why**: Complete audit trail - always know which task/step produced an artifact
- **Implementation**: Unique constraint ensures one artifact per step (for now)

### ✅ **Creator Attribution**
- **Rule**: Every artifact MUST have a creator (`created_by_user_id` NOT NULL)
- **Why**: Accountability and provenance tracking
- **Note**: Usually an agent, but can be a human user

### ✅ **Approval Workflow (OPTIONAL)**
- **Rule**: Artifacts can have an approver (`approved_by_user_id` NULL)
- **Why**: Supports review workflows where orchestrator agents review specialist work
- **Status Flow**: `draft` → `under_review` → `approved` → `archived`

---

## 3. Storage Types

### Current Implementation: Database Storage

**All artifacts currently use `storage_type = 'database'`:**
- Content stored directly in `content` column (text field)
- Simple, reliable, queryable
- Best for: Reports, analyses, markdown documents, JSON data
- Limitations: Not ideal for large binary files or git-tracked code

### Future Storage Options

**The schema supports future pointer-based storage:**

1. **Git Repository** (`storage_type = 'git_repository'`)
   - For code artifacts, version-controlled documents
   - Future table: `artifact_git_pointers` (repo_url, file_path, commit_sha)

2. **Object Storage** (`storage_type = 'object_storage'`)
   - For large files, images, PDFs, videos
   - Future table: `artifact_object_storage_pointers` (provider, bucket, object_key, region)

3. **Web Documents** (`storage_type = 'web_document'`)
   - For external docs (Notion, Google Docs, Confluence)
   - Future table: `artifact_web_document_pointers` (provider, url)

**Migration Path**: When implementing new storage types, the `storage_type` enum discriminates which pointer table to join.

---

## 4. Content Formats

### ✅ **Format Specification**

```typescript
type ArtifactFormat = 'markdown' | 'json' | 'code' | 'text';
```

**Format Usage:**
- **`markdown`** (default): Rich text documents, reports, analyses
  - Rendered with `react-markdown` in UI
  - Supports headings, lists, tables, code blocks
  
- **`json`**: Structured data, API responses, configurations
  - Can be syntax-highlighted and prettified in UI
  - Machine-readable for tool consumption
  
- **`code`**: Source code, scripts, SQL queries
  - Language-specific syntax highlighting
  - Future: Could add `language` field for specific highlighting
  
- **`text`**: Plain text, logs, raw output
  - No special formatting, monospace display

**Best Practice**: Always set `content_format` to match actual content for proper UI rendering.

---

## 5. Artifact Creation Pattern (MCP Tool)

### ✅ **Use `create_artifact` MCP Tool**

The standard way to create artifacts is via the `create_artifact` MCP tool:

```typescript
// Tool call from AI agent
const result = await tools.create_artifact({
  title: "Moderna Stock Analysis Report",
  description: "Comprehensive financial analysis including clinical trials and FDA pipeline",
  content: "# Moderna Stock Analysis\n\n## Executive Summary...",
  contentFormat: "markdown",
  status: "draft"
});
```

**Tool automatically provides:**
- `workspace_id` - From MCP context
- `project_id` - From MCP context
- `source_project_task_step_id` - Current step ID from MCP context
- `created_by_user_id` - Current agent ID from MCP context
- `storage_type` - Defaults to `'database'`
- `created_at`, `updated_at` - Automatic timestamps

**Agent only provides:**
- `title` (required) - Human-readable artifact name
- `description` (optional) - Brief summary of artifact contents
- `content` (required) - The actual artifact content
- `contentFormat` (optional) - Format type, defaults to `'markdown'`
- `status` (optional) - Lifecycle status, defaults to `'draft'`

---

## 6. Artifact Mention System

### ✅ **Chat Message Mentions**

Artifacts can be linked to chat messages via the `chat_message_mentions` table, enabling:
- **Clickable artifact links in UI**: Users can click to view full artifact
- **Traceability**: See which messages reference which artifacts
- **AI Context**: Agents can reference artifacts using friendly IDs (`artifact_id_1`)

**Mention Creation**:
```typescript
import { addArtifactMention } from '@/src/services/supabase/chat-message-mentions-service';

await addArtifactMention({
  chat_message_id: messageId,
  artifact_id: artifactId  // Real UUID
});
```

**Note**: The AI service automatically creates mentions when agents reference artifacts in responses using friendly IDs (e.g., `artifact_id_1`). See `@/src/services/ai/_AI_SERVICE_RULES.md` Section 7 for complete friendly ID mapping implementation.

---

## 7. Artifact Querying Patterns

### ✅ **Service Layer Functions**

**File**: `src/services/supabase/artifacts-service.ts`

```typescript
// Get artifact by ID with all relations
const artifact = await getArtifactWithAllRelations(artifactId);
// Returns: artifact + creator user + approver user + source step

// Get artifacts by step ID
const artifacts = await getArtifactsByStep(stepId);
// Returns: all artifacts created during a specific step

// Get artifacts by task ID
const artifacts = await getArtifactsByTask(taskId);
// Returns: all artifacts created across all steps of a task

// Get recent artifacts by project
const artifacts = await getRecentArtifactsByProject(projectId, limit);
// Returns: N most recent artifacts for a project (for AI context)
```

### ✅ **Database Query Patterns**

**Always use explicit column selection:**

```sql
-- ✅ GOOD: Explicit columns with joins
SELECT 
  a.id, a.title, a.description, a.content, a.content_format,
  a.status, a.created_at,
  creator.id as creator_id, creator.name as creator_name,
  step.id as step_id, step.name as step_name
FROM artifacts a
LEFT JOIN users creator ON a.created_by_user_id = creator.id
LEFT JOIN project_task_steps step ON a.source_project_task_step_id = step.id
WHERE a.project_id = $1
ORDER BY a.created_at DESC;

-- ❌ BAD: SELECT *
SELECT * FROM artifacts;
```

---

## 8. Artifact Lifecycle & Status Management

### ✅ **Status Flow**

```
draft → under_review → approved → archived
  ↑         ↓              ↓          ↓
  └─────────┴──────────────┴──────────┘
        (can transition back for revisions)
```

**Status Definitions:**

1. **`draft`** (default)
   - Initial state when artifact is created
   - Work in progress, may be incomplete
   - Can be edited or deleted

2. **`under_review`**
   - Submitted for approval
   - Awaiting review by orchestrator agent or human
   - Should not be edited during review

3. **`approved`**
   - Reviewed and approved by `approved_by_user_id`
   - Considered final, immutable
   - Primary artifacts for reference

4. **`archived`**
   - No longer active or relevant
   - Kept for historical purposes
   - Can be restored if needed

**Best Practice**: For now, most artifacts stay in `draft` status. The review workflow will be more important as the system grows and quality gates are needed.

---

## 9. Read Artifact Tool

### ✅ **Use `read_artifact` MCP Tool**

Agents can read artifact content via the `read_artifact` tool:

```typescript
// Tool call from AI agent
const artifactData = await tools.read_artifact({
  artifactId: "artifact-uuid-here"
});

// Or using friendly ID (gets mapped to UUID by MCP context)
const artifactData = await tools.read_artifact({
  artifactId: "artifact_id_1"  // Gets mapped to real UUID
});
```

**Returns:**
```json
{
  "id": "uuid",
  "title": "Moderna Stock Analysis Report",
  "description": "Comprehensive analysis...",
  "content": "# Full markdown content...",
  "contentFormat": "markdown",
  "status": "draft",
  "createdBy": {
    "id": "uuid",
    "name": "Stock Research Agent"
  },
  "sourceStep": {
    "id": "uuid",
    "name": "Research Moderna Stock"
  },
  "createdAt": "2025-10-10T14:47:00Z"
}
```

**Use Cases:**
- Orchestrator agents reviewing specialist work
- Summarizing artifacts for human users
- Synthesizing multiple artifacts into reports
- Quality checking before task approval

---

## 10. Best Practices

### ✅ **DO**

1. **Always link to step**: Every artifact MUST have `source_project_task_step_id`
2. **Set meaningful titles**: Use descriptive, human-readable titles
3. **Include descriptions**: Brief summary helps with artifact discovery
4. **Use correct format**: Match `content_format` to actual content type
5. **Scope to project**: Always set `project_id` for project-level artifacts
6. **Use MCP tools**: Use `create_artifact` and `read_artifact` tools, not direct DB access

### ❌ **DON'T**

1. **Don't create orphan artifacts**: Always link to a step
2. **Don't use generic titles**: "Report" is bad, "Moderna Stock Analysis Report" is good
3. **Don't store binary data**: Database storage is for text content only
4. **Don't bypass MCP tools**: Use `create_artifact` tool, not direct database inserts
5. **Don't skip format specification**: Always set `content_format` explicitly
6. **Don't violate workspace scope**: Every artifact must have valid `workspace_id`

---

## 11. UI Integration

### ✅ **Artifact Mentions in Chat**

**Frontend Query Pattern**:

```typescript
// Fetch chat messages with artifact mentions
const { data: messages } = await supabase
  .from('chat_messages')
  .select(`
    id, content, created_at, user_id,
    users!user_id(name, user_type),
    chat_message_mentions(
      id,
      artifacts(
        id, title, description, content_format, status
      )
    )
  `)
  .eq('chat_id', chatId)
  .order('created_at', { ascending: true });
```

**UI Rendering**:
- Parse `content` for artifact reference patterns
- Check `chat_message_mentions` for linked artifacts
- Render clickable artifact cards or links
- Show artifact title, status, and preview

**Component Pattern**:
```tsx
{message.chat_message_mentions?.map(mention => (
  <ArtifactCard
    key={mention.id}
    artifact={mention.artifacts}
    onClick={() => openArtifactViewer(mention.artifacts.id)}
  />
))}
```

---

## 12. Future Enhancements

### Planned Features

1. **Versioning**
   - Track artifact revisions
   - Link updated artifacts to original
   - View artifact history

2. **External Storage**
   - Git repository integration (code artifacts)
   - Object storage (large files, images)
   - Web document links (Notion, Google Docs)

3. **Search & Discovery**
   - Full-text search across artifact content
   - Tag/category system
   - Artifact collections

4. **Collaboration**
   - Multi-agent artifact co-creation
   - Comment threads on artifacts
   - Approval workflows with feedback

5. **Templates**
   - Artifact templates for common outputs
   - Structured artifact types (research report, code module, etc.)

---

## Summary

**Core Principles:**
- **Traceability**: Every artifact links to the step that created it
- **Immutability**: Artifacts are permanent records of agent work
- **Accessibility**: Friendly IDs and mentions make artifacts easy to reference
- **Flexibility**: Schema supports future storage types and workflows
- **Integration**: Seamless connection between artifacts, tasks, and chat

**Key Patterns:**
- **Section 5**: Use `create_artifact` MCP tool with automatic context injection
- **Section 6**: Friendly ID mapping for AI interactions and UI mentions
- **Section 7**: Service layer functions for artifact querying
- **Section 8**: Status lifecycle from draft → review → approved → archived
- **Section 9**: `read_artifact` tool for agent content access

**Related Documentation:**
- `@/src/services/ai/_AI_SERVICE_RULES.md` - AI service artifact integration (Section 7)
- `@/src/lib/supabase/_tools/_MCP_TOOL_RULES.md` - MCP tool development rules
- `@/src/services/supabase/artifacts-service.ts` - Service layer implementation

**Core Principle**: Artifacts are the permanent record of agent work. They provide traceability, enable review workflows, and create a searchable knowledge base of all outputs generated by the agent system.

